"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateProgress = exports.traceStep = exports.withTelemetry = void 0;
const node_1 = require("@sentry/node");
const version_1 = require("./version");
async function withTelemetry(options, callback) {
    const { sentryHub, sentryClient } = createSentryInstance(options.enabled, options.integration);
    (0, node_1.makeMain)(sentryHub);
    const sentrySession = sentryHub.startSession();
    sentryHub.captureSession();
    // Set tag for passed CLI args
    sentryHub.setTag('args.project', !!options.wizardOptions.projectSlug);
    sentryHub.setTag('args.org', !!options.wizardOptions.orgSlug);
    sentryHub.setTag('args.saas', !!options.wizardOptions.saas);
    try {
        return await (0, node_1.startSpan)({
            name: 'sentry-wizard-execution',
            status: 'ok',
            op: 'wizard.flow',
        }, async () => {
            updateProgress('start');
            const res = await (0, node_1.runWithAsyncContext)(callback);
            updateProgress('finished');
            return res;
        });
    }
    catch (e) {
        sentryHub.captureException('Error during wizard execution.');
        sentrySession.status = 'crashed';
        throw e;
    }
    finally {
        sentryHub.endSession();
        await sentryClient.flush(3000).then(null, () => {
            // If telemetry flushing fails we generally don't care
        });
        await (0, node_1.flush)(3000).then(null, () => {
            // If telemetry flushing fails we generally don't care
        });
    }
}
exports.withTelemetry = withTelemetry;
function createSentryInstance(enabled, integration) {
    const client = new node_1.NodeClient({
        dsn: 'https://8871d3ff64814ed8960c96d1fcc98a27@o1.ingest.sentry.io/4505425820712960',
        enabled: enabled,
        environment: `production-${integration}`,
        tracesSampleRate: 1,
        sampleRate: 1,
        release: version_1.WIZARD_VERSION,
        integrations: [new node_1.Integrations.Http()],
        tracePropagationTargets: [/^https:\/\/sentry.io\//],
        stackParser: node_1.defaultStackParser,
        beforeSendTransaction: (event) => {
            delete event.server_name; // Server name might contain PII
            return event;
        },
        beforeSend: (event) => {
            event.exception?.values?.forEach((exception) => {
                delete exception.stacktrace;
            });
            delete event.server_name; // Server name might contain PII
            return event;
        },
        transport: node_1.makeNodeTransport,
        debug: true,
    });
    const hub = new node_1.Hub(client);
    hub.setTag('integration', integration);
    hub.setTag('node', process.version);
    hub.setTag('platform', process.platform);
    try {
        // The `require` call here is fine because the binary node versions
        // support `require` and we try/catch the call anyway for any other
        // version of node.
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        const sea = require('node:sea');
        hub.setTag('is_binary', sea.isSea());
    }
    catch {
        hub.setTag('is_binary', false);
    }
    return { sentryHub: hub, sentryClient: client };
}
function traceStep(step, callback) {
    updateProgress(step);
    return (0, node_1.startSpan)({ name: step, op: 'wizard.step' }, (span) => callback(span));
}
exports.traceStep = traceStep;
function updateProgress(step) {
    (0, node_1.setTag)('progress', step);
}
exports.updateProgress = updateProgress;
//# sourceMappingURL=telemetry.js.map