"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.exportForTesting = exports.addSentryToFastlane = exports.fastFile = void 0;
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const clack_1 = require("../utils/clack");
const templates = __importStar(require("./templates"));
// @ts-expect-error - clack is ESM and TS complains about that. It works though
const clack = __importStar(require("@clack/prompts"));
function fastFile(projectPath) {
    const fastlanePath = path.join(projectPath, 'fastlane', 'Fastfile');
    return fs.existsSync(fastlanePath) ? fastlanePath : null;
}
exports.fastFile = fastFile;
function findIOSPlatform(content) {
    const platformRegex = /^ *platform\s+:([^ ]+)[^\n]*\n/gim;
    let match = platformRegex.exec(content);
    if (!match) {
        // No platform found, treat whole file as one platform.
        return { index: 0, length: content.length };
    }
    let index = -1;
    while (match) {
        if (match[1] === 'ios') {
            index = match.index + match[0].length;
            break;
        }
        match = platformRegex.exec(content);
    }
    if (index === -1) {
        return null;
    }
    //After finding the platform, we need to find the end of the platform block.
    //This solution has the assumption that the file is well formed,
    //which is not a perfect solution, but it's good enough assumption.
    const platformEndRegex = /^end[^\n]*/gim;
    match = platformEndRegex.exec(content.slice(index));
    if (!match) {
        return null;
    }
    return { index, length: match.index };
}
function findLanes(content) {
    const laneRegex = /^ {2}lane\s+:([^ ]+)[^\n]*\n/gim;
    let match = laneRegex.exec(content);
    if (!match) {
        return null;
    }
    const lanes = [];
    while (match) {
        const laneEnd = /^ {2}end/m.exec(content.slice(match.index + match[0].length));
        if (laneEnd === null) {
            return null;
        }
        lanes.push({
            index: match.index + match[0].length,
            length: laneEnd.index,
            name: match[1],
        });
        match = laneRegex.exec(content);
    }
    return lanes;
}
function addSentryToLane(content, lane, org, project) {
    const laneContent = content.slice(lane.index, lane.index + lane.length);
    const sentryCLIMatch = /sentry_cli\s*\([^)]+\)/gim.exec(laneContent);
    if (sentryCLIMatch) {
        // Sentry already added to lane. Update it.
        return (content.slice(0, sentryCLIMatch.index + lane.index) +
            templates.getFastlaneSnippet(org, project).trim() +
            content.slice(sentryCLIMatch.index + sentryCLIMatch[0].length + lane.index));
    }
    // Sentry not added to lane. Add it.
    return (content.slice(0, lane.index + lane.length) +
        '\n' +
        templates.getFastlaneSnippet(org, project) +
        '\n' +
        content.slice(lane.index + lane.length));
}
async function addSentryToFastlane(projectDir, org, project) {
    const fastFilePath = fastFile(projectDir);
    if (!fastFilePath) {
        return false;
    }
    const fileContent = fs.readFileSync(fastFilePath, 'utf8');
    const platform = findIOSPlatform(fileContent);
    if (!platform) {
        return false;
    }
    const platformContent = fileContent.slice(platform.index, platform.index + platform.length);
    const lanes = findLanes(platformContent);
    lanes?.forEach((l) => (l.index += platform.index));
    if (!lanes || lanes.length === 0) {
        clack.log.warn('No suitable lanes in your Fastfile.');
        return false;
    }
    let newFileContent;
    if (lanes.length === 1) {
        newFileContent = addSentryToLane(fileContent, lanes[0], org, project);
    }
    else {
        const laneNames = lanes.map((l) => l.name);
        const selectedLane = await (0, clack_1.askForItemSelection)(laneNames, 'Select lane to add Sentry to:');
        if (selectedLane === undefined) {
            return false;
        }
        newFileContent = addSentryToLane(fileContent, lanes[selectedLane.index], org, project);
    }
    fs.writeFileSync(fastFilePath, newFileContent, 'utf8');
    return true;
}
exports.addSentryToFastlane = addSentryToFastlane;
if (process.env.NODE_ENV === 'test') {
    exports.exportForTesting = {
        findIOSPlatform,
        findLanes,
        addSentryToLane,
    };
}
//# sourceMappingURL=fastlane.js.map