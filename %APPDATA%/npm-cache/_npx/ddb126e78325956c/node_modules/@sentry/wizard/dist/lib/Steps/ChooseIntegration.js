"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChooseIntegration = void 0;
const inquirer_1 = require("inquirer");
const node_fs_1 = require("node:fs");
const package_json_1 = require("../../src/utils/package-json");
const Constants_1 = require("../Constants");
const Logging_1 = require("../Helper/Logging");
const BaseStep_1 = require("./BaseStep");
const Cordova_1 = require("./Integrations/Cordova");
const Electron_1 = require("./Integrations/Electron");
function getProjectPackage() {
    let projectPackage = {};
    const projectPackagePathCandidates = [
        // If we run directly in setup-wizard
        '../../package.json',
        // If we run from the CLI
        `${process.cwd()}/package.json`,
    ];
    for (const pathCandidate of projectPackagePathCandidates) {
        let data;
        try {
            data = (0, node_fs_1.readFileSync)(pathCandidate, 'utf-8');
        }
        catch (error) {
            // If the file does not exist, continue to the next candidate
            continue;
        }
        try {
            projectPackage = JSON.parse(data);
            break;
        }
        catch (error) {
            // If the file exists but is not valid JSON, log an error and continue.
            // Note: we don't want to crash the wizard if the package.json is invalid,
            // because it is only use by the integration detection logic.
            // Furthmore other package managers, i.e. bun, allow JSON-with-comments which might
            // throw errors with JSON.parse, and will require a different JSON parser in the future.
            (0, Logging_1.red)(`Failed to parse JSON from ${pathCandidate}, is your file a valid package.json?`);
        }
    }
    return projectPackage;
}
class ChooseIntegration extends BaseStep_1.BaseStep {
    async emit(_answers) {
        const integrationPrompt = await this._getIntegrationPromptSelection();
        let integration = null;
        switch (integrationPrompt.integration) {
            case Constants_1.Integration.cordova:
                integration = new Cordova_1.Cordova(sanitizeUrl(this._argv));
                break;
            case Constants_1.Integration.electron:
                integration = new Electron_1.Electron(sanitizeUrl(this._argv));
                break;
        }
        return { integration };
    }
    tryDetectingIntegration() {
        const projectPackage = getProjectPackage();
        if ((0, package_json_1.hasPackageInstalled)('react-native', projectPackage)) {
            return Constants_1.Integration.reactNative;
        }
        if ((0, package_json_1.hasPackageInstalled)('cordova', projectPackage)) {
            return Constants_1.Integration.cordova;
        }
        if ((0, package_json_1.hasPackageInstalled)('electron', projectPackage)) {
            return Constants_1.Integration.electron;
        }
        if ((0, package_json_1.hasPackageInstalled)('next', projectPackage)) {
            return Constants_1.Integration.nextjs;
        }
        if ((0, package_json_1.hasPackageInstalled)('remix-run', projectPackage)) {
            return Constants_1.Integration.remix;
        }
        if ((0, package_json_1.hasPackageInstalled)('@sveltejs/kit', projectPackage)) {
            return Constants_1.Integration.sveltekit;
        }
        return;
    }
    async _getIntegrationPromptSelection() {
        // If we receive project type as an arg we skip asking
        if (this._argv.integration) {
            return { integration: this._argv.integration };
        }
        else {
            if (this._argv.quiet) {
                throw new Error('You need to choose a platform');
            }
            const detectedDefaultSelection = this.tryDetectingIntegration();
            return (0, inquirer_1.prompt)([
                {
                    choices: (0, Constants_1.getIntegrationChoices)(),
                    default: detectedDefaultSelection,
                    message: 'What platform do you want to set up?',
                    name: 'integration',
                    type: 'list',
                    pageSize: 10,
                },
            ]);
        }
    }
}
exports.ChooseIntegration = ChooseIntegration;
/**
 * For the `clack`-based wizard flows, which we only shim here, we don't set
 * a default url value. For backwards-compatibility with the other flows,
 * we fill it here and sanitize a user-enterd url.
 */
function sanitizeUrl(argv) {
    if (!argv.url) {
        argv.url = Constants_1.DEFAULT_URL;
        (0, Logging_1.dim)(`no URL provided, fallback to ${argv.url}`);
        return argv;
    }
    let baseUrl = argv.url;
    baseUrl += baseUrl.endsWith('/') ? '' : '/';
    baseUrl = baseUrl.replace(/:\/(?!\/)/g, '://');
    argv.url = baseUrl;
    return argv;
}
//# sourceMappingURL=ChooseIntegration.js.map