"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getModuleExportsAssignmentRight = exports.getMetroConfigObject = exports.addSentryMetroRequireToMetroConfig = exports.addSentrySerializerRequireToMetroConfig = exports.addSentrySerializerToMetroConfig = exports.writeMetroConfig = exports.parseMetroConfig = exports.removeSentryRequire = exports.removeSentrySerializerFromMetroConfig = exports.unPatchMetroConfig = exports.patchMetroConfigWithSentrySerializer = exports.patchMetroWithSentryConfigInMemory = exports.patchMetroWithSentryConfig = exports.metroConfigPath = void 0;
// @ts-expect-error - clack is ESM and TS complains about that. It works though
const clack = __importStar(require("@clack/prompts"));
// @ts-expect-error - magicast is ESM and TS complains about that. It works though
const magicast_1 = require("magicast");
const fs = __importStar(require("fs"));
const Sentry = __importStar(require("@sentry/node"));
const ast_utils_1 = require("../utils/ast-utils");
const clack_1 = require("../utils/clack");
const recast = __importStar(require("recast"));
const chalk_1 = __importDefault(require("chalk"));
const b = recast.types.builders;
exports.metroConfigPath = 'metro.config.js';
async function patchMetroWithSentryConfig() {
    const mod = await parseMetroConfig();
    const showInstructions = () => (0, clack_1.showCopyPasteInstructions)({
        filename: exports.metroConfigPath,
        codeSnippet: getMetroWithSentryConfigSnippet(true),
    });
    const success = await patchMetroWithSentryConfigInMemory(mod, showInstructions);
    if (!success) {
        return;
    }
    const saved = await writeMetroConfig(mod);
    if (saved) {
        clack.log.success(chalk_1.default.green(`${chalk_1.default.cyan(exports.metroConfigPath)} changes saved.`));
    }
    else {
        clack.log.warn(`Could not save changes to ${chalk_1.default.cyan(exports.metroConfigPath)}, please follow the manual steps.`);
        return await showInstructions();
    }
}
exports.patchMetroWithSentryConfig = patchMetroWithSentryConfig;
async function patchMetroWithSentryConfigInMemory(mod, showInstructions) {
    if ((0, ast_utils_1.hasSentryContent)(mod.$ast)) {
        const shouldContinue = await confirmPathMetroConfig();
        if (!shouldContinue) {
            await showInstructions();
            return false;
        }
    }
    const configExpression = getModuleExportsAssignmentRight(mod.$ast);
    if (!configExpression) {
        clack.log.warn('Could not find Metro config, please follow the manual steps.');
        await showInstructions();
        return false;
    }
    const wrappedConfig = wrapWithSentryConfig(configExpression);
    const replacedModuleExportsRight = replaceModuleExportsRight(mod.$ast, wrappedConfig);
    if (!replacedModuleExportsRight) {
        clack.log.warn('Could not automatically wrap the config export, please follow the manual steps.');
        await showInstructions();
        return false;
    }
    const addedSentryMetroImport = addSentryMetroRequireToMetroConfig(mod.$ast);
    if (!addedSentryMetroImport) {
        clack.log.warn('Could not add `@sentry/react-native/metro` import to Metro config, please follow the manual steps.');
        await showInstructions();
        return false;
    }
    clack.log.success(`Added Sentry Metro plugin to ${chalk_1.default.cyan(exports.metroConfigPath)}.`);
    return true;
}
exports.patchMetroWithSentryConfigInMemory = patchMetroWithSentryConfigInMemory;
async function patchMetroConfigWithSentrySerializer() {
    const mod = await parseMetroConfig();
    const showInstructions = () => (0, clack_1.showCopyPasteInstructions)({
        filename: exports.metroConfigPath,
        codeSnippet: getMetroSentrySerializerSnippet(true),
    });
    if ((0, ast_utils_1.hasSentryContent)(mod.$ast)) {
        const shouldContinue = await confirmPathMetroConfig();
        if (!shouldContinue) {
            return await showInstructions();
        }
    }
    const configObj = getMetroConfigObject(mod.$ast);
    if (!configObj) {
        clack.log.warn('Could not find Metro config object, please follow the manual steps.');
        return showInstructions();
    }
    const addedSentrySerializer = addSentrySerializerToMetroConfig(configObj);
    if (!addedSentrySerializer) {
        clack.log.warn('Could not add Sentry serializer to Metro config, please follow the manual steps.');
        return await showInstructions();
    }
    const addedSentrySerializerImport = addSentrySerializerRequireToMetroConfig(mod.$ast);
    if (!addedSentrySerializerImport) {
        clack.log.warn('Could not add Sentry serializer import to Metro config, please follow the manual steps.');
        return await showInstructions();
    }
    clack.log.success(`Added Sentry Metro plugin to ${chalk_1.default.cyan(exports.metroConfigPath)}.`);
    const saved = await writeMetroConfig(mod);
    if (saved) {
        clack.log.success(chalk_1.default.green(`${chalk_1.default.cyan(exports.metroConfigPath)} changes saved.`));
    }
    else {
        clack.log.warn(`Could not save changes to ${chalk_1.default.cyan(exports.metroConfigPath)}, please follow the manual steps.`);
        return await showInstructions();
    }
}
exports.patchMetroConfigWithSentrySerializer = patchMetroConfigWithSentrySerializer;
async function unPatchMetroConfig() {
    const mod = await parseMetroConfig();
    const removedAtLeastOneRequire = removeSentryRequire(mod.$ast);
    const removedSerializerConfig = removeSentrySerializerFromMetroConfig(mod.$ast);
    if (removedAtLeastOneRequire || removedSerializerConfig) {
        const saved = await writeMetroConfig(mod);
        if (saved) {
            clack.log.success(`Removed Sentry Metro plugin from ${chalk_1.default.cyan(exports.metroConfigPath)}.`);
        }
    }
    else {
        clack.log.warn(`No Sentry Metro plugin found in ${chalk_1.default.cyan(exports.metroConfigPath)}.`);
    }
}
exports.unPatchMetroConfig = unPatchMetroConfig;
function removeSentrySerializerFromMetroConfig(program) {
    const configObject = getMetroConfigObject(program);
    if (!configObject) {
        return false;
    }
    const serializerProp = getSerializerProp(configObject);
    if ('invalid' === serializerProp || 'undefined' === serializerProp) {
        return false;
    }
    const customSerializerProp = getCustomSerializerProp(serializerProp);
    if ('invalid' === customSerializerProp ||
        'undefined' === customSerializerProp) {
        return false;
    }
    if (serializerProp.value.type === 'ObjectExpression' &&
        customSerializerProp.value.type === 'CallExpression' &&
        customSerializerProp.value.callee.type === 'Identifier' &&
        customSerializerProp.value.callee.name === 'createSentryMetroSerializer') {
        if (customSerializerProp.value.arguments.length === 0) {
            // FROM serializer: { customSerializer: createSentryMetroSerializer() }
            // TO serializer: {}
            let removed = false;
            serializerProp.value.properties = serializerProp.value.properties.filter((p) => {
                if (p.type === 'ObjectProperty' &&
                    p.key.type === 'Identifier' &&
                    p.key.name === 'customSerializer') {
                    removed = true;
                    return false;
                }
                return true;
            });
            if (removed) {
                return true;
            }
        }
        else {
            if (customSerializerProp.value.arguments[0].type !== 'SpreadElement') {
                // FROM serializer: { customSerializer: createSentryMetroSerializer(wrapperSerializer) }
                // TO serializer: { customSerializer: wrapperSerializer }
                customSerializerProp.value = customSerializerProp.value.arguments[0];
                return true;
            }
        }
    }
    return false;
}
exports.removeSentrySerializerFromMetroConfig = removeSentrySerializerFromMetroConfig;
function removeSentryRequire(program) {
    return (0, ast_utils_1.removeRequire)(program, '@sentry');
}
exports.removeSentryRequire = removeSentryRequire;
async function parseMetroConfig() {
    const metroConfigContent = (await fs.promises.readFile(exports.metroConfigPath)).toString();
    return (0, magicast_1.parseModule)(metroConfigContent);
}
exports.parseMetroConfig = parseMetroConfig;
async function writeMetroConfig(mod) {
    try {
        await (0, magicast_1.writeFile)(mod.$ast, exports.metroConfigPath);
    }
    catch (e) {
        clack.log.error(`Failed to write to ${chalk_1.default.cyan(exports.metroConfigPath)}: ${JSON.stringify(e)}`);
        return false;
    }
    return true;
}
exports.writeMetroConfig = writeMetroConfig;
function addSentrySerializerToMetroConfig(configObj) {
    const serializerProp = getSerializerProp(configObj);
    if ('invalid' === serializerProp) {
        return false;
    }
    // case 1: serializer property doesn't exist yet, so we can just add it
    if ('undefined' === serializerProp) {
        configObj.properties.push(b.objectProperty(b.identifier('serializer'), b.objectExpression([
            b.objectProperty(b.identifier('customSerializer'), b.callExpression(b.identifier('createSentryMetroSerializer'), [])),
        ])));
        return true;
    }
    const customSerializerProp = getCustomSerializerProp(serializerProp);
    // case 2: serializer.customSerializer property doesn't exist yet, so we just add it
    if ('undefined' === customSerializerProp &&
        serializerProp.value.type === 'ObjectExpression') {
        serializerProp.value.properties.push(b.objectProperty(b.identifier('customSerializer'), b.callExpression(b.identifier('createSentryMetroSerializer'), [])));
        return true;
    }
    return false;
}
exports.addSentrySerializerToMetroConfig = addSentrySerializerToMetroConfig;
function getCustomSerializerProp(prop) {
    const customSerializerProp = prop.value.type === 'ObjectExpression' &&
        prop.value.properties.find((p) => p.key.type === 'Identifier' && p.key.name === 'customSerializer');
    if (!customSerializerProp) {
        return 'undefined';
    }
    if (customSerializerProp.type === 'ObjectProperty') {
        return customSerializerProp;
    }
    return 'invalid';
}
function getSerializerProp(obj) {
    const serializerProp = obj.properties.find((p) => p.key.type === 'Identifier' && p.key.name === 'serializer');
    if (!serializerProp) {
        return 'undefined';
    }
    if (serializerProp.type === 'ObjectProperty') {
        return serializerProp;
    }
    return 'invalid';
}
function addSentrySerializerRequireToMetroConfig(program) {
    const lastRequireIndex = (0, ast_utils_1.getLastRequireIndex)(program);
    const sentrySerializerRequire = createSentrySerializerRequire();
    const sentryImportIndex = lastRequireIndex + 1;
    if (sentryImportIndex < program.body.length) {
        // insert after last require
        program.body.splice(lastRequireIndex + 1, 0, sentrySerializerRequire);
    }
    else {
        // insert at the beginning
        program.body.unshift(sentrySerializerRequire);
    }
    return true;
}
exports.addSentrySerializerRequireToMetroConfig = addSentrySerializerRequireToMetroConfig;
function addSentryMetroRequireToMetroConfig(program) {
    const lastRequireIndex = (0, ast_utils_1.getLastRequireIndex)(program);
    const sentryMetroRequire = createSentryMetroRequire();
    const sentryImportIndex = lastRequireIndex + 1;
    if (sentryImportIndex < program.body.length) {
        // insert after last require
        program.body.splice(lastRequireIndex + 1, 0, sentryMetroRequire);
    }
    else {
        // insert at the beginning
        program.body.unshift(sentryMetroRequire);
    }
    return true;
}
exports.addSentryMetroRequireToMetroConfig = addSentryMetroRequireToMetroConfig;
function wrapWithSentryConfig(configObj) {
    return b.callExpression(b.identifier('withSentryConfig'), [configObj]);
}
function replaceModuleExportsRight(program, wrappedConfig) {
    const moduleExports = getModuleExports(program);
    if (!moduleExports) {
        return false;
    }
    if (moduleExports.expression.type === 'AssignmentExpression') {
        moduleExports.expression.right = wrappedConfig;
        return true;
    }
    return false;
}
/**
 * Creates const {createSentryMetroSerializer} = require('@sentry/react-native/dist/js/tools/sentryMetroSerializer');
 */
function createSentrySerializerRequire() {
    return b.variableDeclaration('const', [
        b.variableDeclarator(b.objectPattern([
            b.objectProperty.from({
                key: b.identifier('createSentryMetroSerializer'),
                value: b.identifier('createSentryMetroSerializer'),
                shorthand: true,
            }),
        ]), b.callExpression(b.identifier('require'), [
            b.literal('@sentry/react-native/dist/js/tools/sentryMetroSerializer'),
        ])),
    ]);
}
/**
 * Creates const {withSentryConfig} = require('@sentry/react-native/metro');
 */
function createSentryMetroRequire() {
    return b.variableDeclaration('const', [
        b.variableDeclarator(b.objectPattern([
            b.objectProperty.from({
                key: b.identifier('withSentryConfig'),
                value: b.identifier('withSentryConfig'),
                shorthand: true,
            }),
        ]), b.callExpression(b.identifier('require'), [
            b.literal('@sentry/react-native/metro'),
        ])),
    ]);
}
async function confirmPathMetroConfig() {
    const shouldContinue = await (0, clack_1.abortIfCancelled)(clack.select({
        message: `Metro Config already contains Sentry-related code. Should the wizard modify it anyway?`,
        options: [
            {
                label: 'Yes, add the Sentry Metro plugin',
                value: true,
            },
            {
                label: 'No, show me instructions to manually add the plugin',
                value: false,
            },
        ],
        initialValue: true,
    }));
    if (!shouldContinue) {
        Sentry.setTag('ast-mod-fail-reason', 'has-sentry-content');
    }
    return shouldContinue;
}
/**
 * Returns value from `module.exports = value` or `const config = value`
 */
function getMetroConfigObject(program) {
    // check config variable
    const configVariable = program.body.find((s) => {
        if (s.type === 'VariableDeclaration' &&
            s.declarations.length === 1 &&
            s.declarations[0].type === 'VariableDeclarator' &&
            s.declarations[0].id.type === 'Identifier' &&
            s.declarations[0].id.name === 'config') {
            return true;
        }
        return false;
    });
    if (configVariable?.declarations[0].type === 'VariableDeclarator' &&
        configVariable?.declarations[0].init?.type === 'ObjectExpression') {
        Sentry.setTag('metro-config', 'config-variable');
        return configVariable.declarations[0].init;
    }
    return getModuleExportsObject(program);
}
exports.getMetroConfigObject = getMetroConfigObject;
function getModuleExportsObject(program) {
    // check module.exports
    const moduleExports = getModuleExportsAssignmentRight(program);
    if (moduleExports?.type === 'ObjectExpression') {
        return moduleExports;
    }
    Sentry.setTag('metro-config', 'not-found');
    return undefined;
}
function getModuleExportsAssignmentRight(program) {
    // check module.exports
    const moduleExports = getModuleExports(program);
    if (moduleExports?.expression.type === 'AssignmentExpression' &&
        (moduleExports.expression.right.type === 'ObjectExpression' ||
            moduleExports.expression.right.type === 'CallExpression' ||
            moduleExports.expression.right.type === 'Identifier')) {
        Sentry.setTag('metro-config', 'module-exports');
        return moduleExports?.expression.right;
    }
    Sentry.setTag('metro-config', 'not-found');
    return undefined;
}
exports.getModuleExportsAssignmentRight = getModuleExportsAssignmentRight;
function getModuleExports(program) {
    // find module.exports
    return program.body.find((s) => {
        if (s.type === 'ExpressionStatement' &&
            s.expression.type === 'AssignmentExpression' &&
            s.expression.left.type === 'MemberExpression' &&
            s.expression.left.object.type === 'Identifier' &&
            s.expression.left.object.name === 'module' &&
            s.expression.left.property.type === 'Identifier' &&
            s.expression.left.property.name === 'exports') {
            return true;
        }
        return false;
    });
}
function getMetroSentrySerializerSnippet(colors) {
    return (0, clack_1.makeCodeSnippet)(colors, (unchanged, plus, _) => unchanged(`const {getDefaultConfig, mergeConfig} = require('@react-native/metro-config');";
${plus("const {createSentryMetroSerializer} = require('@sentry/react-native/dist/js/tools/sentryMetroSerializer');")}

const config = {
  ${plus(`serializer: {
    customSerializer: createSentryMetroSerializer(),
  },`)}
};

module.exports = mergeConfig(getDefaultConfig(__dirname), config);
`));
}
function getMetroWithSentryConfigSnippet(colors) {
    return (0, clack_1.makeCodeSnippet)(colors, (unchanged, plus, _) => unchanged(`const {getDefaultConfig, mergeConfig} = require('@react-native/metro-config');";
${plus("const {withSentryConfig} = require('@sentry/react-native/metro');")}

const config = {};

module.exports = ${plus('withSentryConfig(')}mergeConfig(getDefaultConfig(__dirname), config)${plus(')')};
`));
}
//# sourceMappingURL=metro.js.map