{"version":3,"file":"ast-utils.js","sourceRoot":"","sources":["../../../src/utils/ast-utils.ts"],"names":[],"mappings":"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","sourcesContent":["import * as fs from 'fs';\n\nimport * as recast from 'recast';\nimport x = recast.types;\nimport t = x.namedTypes;\n\nconst b = recast.types.builders;\n\n/**\n * Checks if a file where we don't know its concrete file type yet exists\n * and returns the full path to the file with the correct file type.\n */\nexport function findFile(\n  filePath: string,\n  fileTypes: string[] = ['.js', '.ts', '.mjs', '.cjs'],\n): string | undefined {\n  return fileTypes\n    .map((type) => `${filePath}${type}`)\n    .find((file) => fs.existsSync(file));\n}\n\n/**\n * checks for require('@sentry/*') syntax\n */\nexport function hasSentryContent(program: t.Program): boolean {\n  let foundSentry: boolean | undefined = false;\n  recast.visit(program, {\n    visitStringLiteral(path) {\n      foundSentry = foundSentry || path.node.value.startsWith('@sentry/');\n      this.traverse(path);\n    },\n    visitLiteral(path) {\n      foundSentry =\n        foundSentry || path.node.value?.toString().startsWith('@sentry/');\n      this.traverse(path);\n    },\n  });\n\n  return !!foundSentry;\n}\n\n/**\n * Searches for a property of an ObjectExpression by name\n *\n * @param object the ObjectExpression to search in\n * @param name the name of the property to search for\n *\n * @returns the property if it exists\n */\nexport function getObjectProperty(\n  object: t.ObjectExpression,\n  name: string,\n): t.Property | undefined {\n  return object.properties.find((p): p is t.Property => {\n    const isObjectProp = p.type === 'Property' || p.type === 'ObjectProperty';\n\n    if (!isObjectProp) {\n      return false;\n    }\n\n    const hasMatchingLiteralKey =\n      isObjectProp &&\n      (p.key.type === 'Literal' || p.key.type === 'StringLiteral') &&\n      p.key.value === name;\n\n    if (hasMatchingLiteralKey) {\n      return true;\n    }\n\n    // has matching identifier key\n    return isObjectProp && p.key.type === 'Identifier' && p.key.name === name;\n  });\n}\n\n/**\n * Attempts to find a property of an ObjectExpression by name. If it doesn't exist,\n * the property will be added to the ObjectExpression with the provided default value.\n *\n * @param object the parent object expression to search in\n * @param name the name of the property to search for\n * @param defaultValue the default value to set if the property doesn't exist\n *\n * @returns the\n */\nexport function getOrSetObjectProperty(\n  object: t.ObjectExpression,\n  name: string,\n  defaultValue:\n    | t.Literal\n    | t.BooleanLiteral\n    | t.StringLiteral\n    | t.ObjectExpression,\n): t.Property {\n  const existingProperty = getObjectProperty(object, name);\n\n  if (existingProperty) {\n    return existingProperty;\n  }\n\n  const newProperty = b.property.from({\n    kind: 'init',\n    key: b.stringLiteral(name),\n    value: defaultValue,\n  });\n\n  object.properties.push(newProperty);\n\n  return newProperty;\n}\n\n/**\n * Sets a property of an ObjectExpression if it exists, otherwise adds it\n * to the ObjectExpression. Optionally, a comment can be added to the\n * property.\n *\n * @param object the ObjectExpression to set the property on\n * @param name the name of the property to set\n * @param value  the value of the property to set\n * @param comment (optional) a comment to add to the property\n */\nexport function setOrUpdateObjectProperty(\n  object: t.ObjectExpression,\n  name: string,\n  value: t.Literal | t.BooleanLiteral | t.StringLiteral | t.ObjectExpression,\n  comment?: string,\n) {\n  const newComments =\n    comment &&\n    comment.split('\\n').map((c) => b.commentLine(` ${c}`, true, false));\n\n  const existingProperty = getObjectProperty(object, name);\n\n  if (existingProperty) {\n    existingProperty.value = value;\n    if (newComments) {\n      existingProperty.comments = [\n        ...(existingProperty?.comments || []),\n        ...newComments,\n      ];\n    }\n  } else {\n    object.properties.push(\n      b.objectProperty.from({\n        key: b.stringLiteral(name),\n        value,\n        ...(newComments && {\n          comments: newComments,\n        }),\n      }),\n    );\n  }\n}\n\ntype JsonCParseResult =\n  | {\n      jsonObject: t.ObjectExpression;\n      ast: t.Program;\n    }\n  | {\n      jsonObject: undefined;\n      ast: undefined;\n    };\n\n/**\n * Parses a JSON string with (potential) comments (JSON-C) and returns the JS AST\n * that can be walked and modified with recast like a normal JS AST.\n *\n * This is done by wrapping the JSON-C string in parentheses, thereby making it\n * a JS `Program` with an `ExpressionStatement` as its body. The expression is then\n * extracted from the AST and returned alongside the AST.\n *\n * To preserve as much original formatting as possible, the returned `ast`\n * property should be passed to {@link `printJsonC`} to get the JSON-C string back.\n *\n * If the input is not valid JSON-C, the result will be undefined.\n *\n * @see {@link JsonCParseResult}\n *\n * @param jsonString a JSON-C string\n *\n * @returns a {@link JsonCParseResult}, containing either the JSON-C object and the AST or undefined in both cases\n */\nexport function parseJsonC(jsonString: string): JsonCParseResult {\n  try {\n    const jsTsConfig = `(${jsonString})`;\n    // no idea why recast returns any here, this is dumb :/\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    const ast = recast.parse(jsTsConfig.toString()).program as t.Program;\n\n    const jsonObject =\n      (ast.body[0].type === 'ExpressionStatement' &&\n        ast.body[0].expression.type === 'ObjectExpression' &&\n        ast.body[0].expression) ||\n      undefined;\n\n    if (jsonObject) {\n      return { jsonObject, ast };\n    }\n  } catch {\n    /* empty */\n  }\n  return { jsonObject: undefined, ast: undefined };\n}\n\n/**\n * Takes the AST of a parsed JSON-C \"program\" and returns the JSON-C string without\n * any of the temporary JS wrapper code that was previously applied.\n *\n * Only use this in conjunction with {@link `parseJsonC`}\n *\n * @param ast the `ast` returned from {@link `parseJsonC`}\n *\n * @returns the JSON-C string\n */\nexport function printJsonC(ast: t.Program): string {\n  const js = recast.print(ast).code;\n  return js.substring(1, js.length - 1);\n}\n\n/**\n * Walks the program body and returns index of the last variable assignment initialized by require statement.\n * Only counts top level require statements.\n *\n * @returns index of the last `const foo = require('bar');` statement or -1 if none was found.\n */\nexport function getLastRequireIndex(program: t.Program): number {\n  let lastRequireIdex = -1;\n  program.body.forEach((s, i) => {\n    if (\n      s.type === 'VariableDeclaration' &&\n      s.declarations[0].type === 'VariableDeclarator' &&\n      s.declarations[0].init !== null &&\n      typeof s.declarations[0].init !== 'undefined' &&\n      s.declarations[0].init.type === 'CallExpression' &&\n      s.declarations[0].init.callee.type === 'Identifier' &&\n      s.declarations[0].init.callee.name === 'require'\n    ) {\n      lastRequireIdex = i;\n    }\n  });\n  return lastRequireIdex;\n}\n\n/**\n * Walks the statements and removes require statements which first argument includes the predicate.\n * Only removes top level require statements like `const foo = require('bar');`\n *\n * @returns True if any require statement was removed.\n */\nexport function removeRequire(program: t.Program, predicate: string): boolean {\n  let removedAtLeastOne = false;\n  program.body = program.body.filter((s) => {\n    if (\n      s.type === 'VariableDeclaration' &&\n      s.declarations[0].type === 'VariableDeclarator' &&\n      s.declarations[0].init !== null &&\n      typeof s.declarations[0].init !== 'undefined' &&\n      s.declarations[0].init.type === 'CallExpression' &&\n      s.declarations[0].init.callee.type === 'Identifier' &&\n      s.declarations[0].init.callee.name === 'require' &&\n      s.declarations[0].init.arguments[0].type === 'StringLiteral' &&\n      s.declarations[0].init.arguments[0].value.includes(predicate)\n    ) {\n      removedAtLeastOne = true;\n      return false;\n    }\n    return true;\n  });\n  return removedAtLeastOne;\n}\n"]}