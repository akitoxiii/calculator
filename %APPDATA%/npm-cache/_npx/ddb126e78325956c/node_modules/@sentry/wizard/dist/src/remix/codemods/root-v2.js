"use strict";
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
/* eslint-disable @typescript-eslint/no-unsafe-call */
/* eslint-disable @typescript-eslint/no-unsafe-argument */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.instrumentRootRouteV2 = void 0;
const recast = __importStar(require("recast"));
const path = __importStar(require("path"));
// @ts-expect-error - magicast is ESM and TS complains about that. It works though
const magicast_1 = require("magicast");
const templates_1 = require("../templates");
const utils_1 = require("../utils");
const root_common_1 = require("./root-common");
async function instrumentRootRouteV2(rootFileName) {
    const rootRouteAst = await (0, magicast_1.loadFile)(path.join(process.cwd(), 'app', rootFileName));
    const exportsAst = rootRouteAst.exports.$ast;
    const namedExports = exportsAst.body.filter((node) => node.type === 'ExportNamedDeclaration');
    let foundErrorBoundary = false;
    namedExports.forEach((namedExport) => {
        const declaration = namedExport.declaration;
        if (!declaration) {
            return;
        }
        if (declaration.type === 'FunctionDeclaration') {
            if (declaration.id?.name === 'ErrorBoundary') {
                foundErrorBoundary = true;
            }
        }
        else if (declaration.type === 'VariableDeclaration') {
            const declarations = declaration.declarations;
            declarations.forEach((declaration) => {
                // @ts-expect-error - id should always have a name in this case
                if (declaration.id?.name === 'ErrorBoundary') {
                    foundErrorBoundary = true;
                }
            });
        }
    });
    if (!foundErrorBoundary) {
        rootRouteAst.imports.$add({
            from: '@sentry/remix',
            imported: 'captureRemixErrorBoundaryError',
            local: 'captureRemixErrorBoundaryError',
        });
        rootRouteAst.imports.$add({
            from: '@remix-run/react',
            imported: 'useRouteError',
            local: 'useRouteError',
        });
        recast.visit(rootRouteAst.$ast, {
            visitExportDefaultDeclaration(path) {
                const implementation = recast.parse(templates_1.ERROR_BOUNDARY_TEMPLATE_V2).program
                    .body[0];
                path.insertBefore(recast.types.builders.exportDeclaration(false, implementation));
                this.traverse(path);
            },
        });
        // If there is already a ErrorBoundary export, and it doesn't have Sentry content
    }
    else if (!(0, utils_1.hasSentryContent)(rootFileName, rootRouteAst.$code)) {
        rootRouteAst.imports.$add({
            from: '@sentry/remix',
            imported: 'captureRemixErrorBoundaryError',
            local: 'captureRemixErrorBoundaryError',
        });
        (0, root_common_1.wrapAppWithSentry)(rootRouteAst, rootFileName);
        recast.visit(rootRouteAst.$ast, {
            visitExportNamedDeclaration(path) {
                // Find ErrorBoundary export
                if (path.value.declaration?.id?.name === 'ErrorBoundary') {
                    const errorBoundaryExport = path.value.declaration;
                    let errorIdentifier;
                    // check if useRouteError is called
                    recast.visit(errorBoundaryExport, {
                        visitVariableDeclaration(path) {
                            const variableDeclaration = path.value.declarations[0];
                            const initializer = variableDeclaration.init;
                            if (initializer.type === 'CallExpression' &&
                                initializer.callee.name === 'useRouteError') {
                                errorIdentifier = variableDeclaration.id.name;
                            }
                            this.traverse(path);
                        },
                    });
                    // We don't have an errorIdentifier, which means useRouteError is not called / imported
                    // We need to add it and capture the error
                    if (!errorIdentifier) {
                        rootRouteAst.imports.$add({
                            from: '@remix-run/react',
                            imported: 'useRouteError',
                            local: 'useRouteError',
                        });
                        const useRouteErrorCall = recast.parse(`const error = useRouteError();`).program.body[0];
                        // Insert at the top of ErrorBoundary body
                        errorBoundaryExport.body.body.splice(0, 0, useRouteErrorCall);
                    }
                    const captureErrorCall = recast.parse(`captureRemixErrorBoundaryError(error);`).program.body[0];
                    // Insert just before the the fallback page is returned
                    errorBoundaryExport.body.body.splice(errorBoundaryExport.body.body.length - 1, 0, captureErrorCall);
                }
                this.traverse(path);
            },
        });
    }
    await (0, magicast_1.writeFile)(rootRouteAst.$ast, path.join(process.cwd(), 'app', rootFileName));
}
exports.instrumentRootRouteV2 = instrumentRootRouteV2;
//# sourceMappingURL=root-v2.js.map