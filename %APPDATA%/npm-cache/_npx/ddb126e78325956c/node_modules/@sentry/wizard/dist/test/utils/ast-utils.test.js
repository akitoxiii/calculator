"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const ast_utils_1 = require("../../src/utils/ast-utils");
const recast = __importStar(require("recast"));
const b = recast.types.builders;
const vitest_1 = require("vitest");
(0, vitest_1.describe)('hasSentryContent', () => {
    vitest_1.it.each([
        `
      const { sentryVitePlugin } = require("@sentry/vite-plugin");
      const somethingelse = require('gs');
    `,
        `
        import { sentryVitePlugin } from "@sentry/vite-plugin";
        import * as somethingelse from 'gs';

        export default {
            plugins: [sentryVitePlugin()]
        }
      `,
    ])("returns true if a require('@sentry/') call was found in the parsed module", (code) => {
        // recast.parse returns a Program node (or fails) but it's badly typed as any
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        const program = recast.parse(code)
            .program;
        (0, vitest_1.expect)((0, ast_utils_1.hasSentryContent)(program)).toBe(true);
    });
    vitest_1.it.each([
        `const whatever = require('something')`,
        `// const {sentryWebpackPlugin} = require('@sentry/webpack-plugin')`,
        `const {sAntryWebpackPlugin} = require('webpack-plugin-@sentry')`,
        `
      import * as somethingelse from 'gs';
      export default {
          plugins: []
      }
      `,
        `import * as somethingelse from 'gs';
       // import { sentryVitePlugin } from "@sentry/vite-plugin"
      export default {
          plugins: []
      }
      `,
        `import * as thirdPartyVitePlugin from "vite-plugin-@sentry"
      export default {
        plugins: [thirdPartyVitePlugin()]
      }
      `,
    ])("returns false if the file doesn't contain any require('@sentry/') calls", (code) => {
        // recast.parse returns a Program node (or fails) but it's badly typed as any
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        const program = recast.parse(code)
            .program;
        (0, vitest_1.expect)((0, ast_utils_1.hasSentryContent)(program)).toBe(false);
    });
});
(0, vitest_1.describe)('getObjectProperty', () => {
    vitest_1.it.each([
        [
            'literal',
            b.objectExpression([
                b.objectProperty(b.identifier('foo'), b.stringLiteral('bar')),
                b.objectProperty(b.stringLiteral('needle'), b.stringLiteral('haystack')),
            ]),
        ],
        [
            'stringLiteral',
            b.objectExpression([
                b.objectProperty(b.identifier('foo'), b.stringLiteral('bar')),
                b.objectProperty(b.literal('needle'), b.stringLiteral('haystack')),
            ]),
        ],
        [
            'identifier',
            b.objectExpression([
                b.objectProperty(b.identifier('foo'), b.stringLiteral('bar')),
                b.objectProperty(b.identifier('needle'), b.stringLiteral('haystack')),
            ]),
        ],
    ])('returns the poperty (%s) if it exists', (_, object) => {
        const property = (0, ast_utils_1.getObjectProperty)(object, 'needle');
        (0, vitest_1.expect)(property).toBeDefined();
        // @ts-expect-error we know it's defined due to the expect above
        (0, vitest_1.expect)(recast.print(property).code).toEqual(vitest_1.expect.stringContaining('needle'));
    });
    (0, vitest_1.it)('returns undefined if the property does not exist', () => {
        const object = b.objectExpression([
            b.objectProperty(b.identifier('foo'), b.stringLiteral('bar')),
        ]);
        const property = (0, ast_utils_1.getObjectProperty)(object, 'needle');
        (0, vitest_1.expect)(property).toBeUndefined();
    });
    (0, vitest_1.it)('handles objects without simple properties', () => {
        const object = b.objectExpression([b.spreadElement(b.identifier('foo'))]);
        const property = (0, ast_utils_1.getObjectProperty)(object, 'needle');
        (0, vitest_1.expect)(property).toBeUndefined();
    });
});
(0, vitest_1.describe)('getOrSetObjectProperty', () => {
    (0, vitest_1.it)('returns the property if it exists', () => {
        const object = b.objectExpression([
            b.objectProperty(b.identifier('needle'), b.stringLiteral('haystack')),
        ]);
        const property = (0, ast_utils_1.getOrSetObjectProperty)(object, 'needle', b.stringLiteral('nope'));
        (0, vitest_1.expect)(property).toBeDefined();
        (0, vitest_1.expect)(property.type).toBe('ObjectProperty');
        // @ts-expect-error we know its type
        (0, vitest_1.expect)(property.key.name).toBe('needle');
        // @ts-expect-error we know its type
        (0, vitest_1.expect)(property.value.value).toBe('haystack');
    });
    (0, vitest_1.it)('adds the property if it does not exist', () => {
        const object = b.objectExpression([
            b.objectProperty(b.identifier('foo'), b.stringLiteral('bar')),
        ]);
        const property = (0, ast_utils_1.getOrSetObjectProperty)(object, 'needle', b.stringLiteral('haystack'));
        (0, vitest_1.expect)(property).toBeDefined();
        (0, vitest_1.expect)(property.type).toBe('Property');
        // @ts-expect-error we know its type
        (0, vitest_1.expect)(property.key.value).toBe('needle');
        // @ts-expect-error we know its type
        (0, vitest_1.expect)(property.value.value).toBe('haystack');
    });
});
(0, vitest_1.describe)('setOrUpdateObjectProperty', () => {
    (0, vitest_1.it)('sets a new property if it does not exist yet', () => {
        const object = b.objectExpression([
            b.objectProperty(b.identifier('foo'), b.stringLiteral('bar')),
        ]);
        (0, ast_utils_1.setOrUpdateObjectProperty)(object, 'needle', b.stringLiteral('haystack'));
        (0, vitest_1.expect)((0, ast_utils_1.getObjectProperty)(object, 'needle')).toBeDefined();
    });
    (0, vitest_1.it)('updates an existing property if it exists', () => {
        const object = b.objectExpression([
            b.objectProperty(b.identifier('foo'), b.stringLiteral('bar')),
            b.objectProperty(b.identifier('needle'), b.stringLiteral('haystack')),
        ]);
        (0, ast_utils_1.setOrUpdateObjectProperty)(object, 'needle', b.stringLiteral('haystack2'));
        const property = (0, ast_utils_1.getObjectProperty)(object, 'needle');
        // @ts-expect-error it must be defiend, otherwise we fail anyway
        (0, vitest_1.expect)(property?.value.value).toBe('haystack2');
    });
    (0, vitest_1.it)('adds a comment to the existing property if provided', () => {
        const object = b.objectExpression([
            b.objectProperty(b.identifier('foo'), b.stringLiteral('bar')),
        ]);
        (0, ast_utils_1.setOrUpdateObjectProperty)(object, 'needle', b.stringLiteral('haystack'), 'This is a comment');
        const property = (0, ast_utils_1.getObjectProperty)(object, 'needle');
        (0, vitest_1.expect)(property?.comments).toHaveLength(1);
        // @ts-expect-error it must be defiend, otherwise we fail anyway
        (0, vitest_1.expect)(property?.comments[0].value).toBe(' This is a comment');
    });
    (0, vitest_1.it)('adds a comment to the new property if provided', () => {
        const object = b.objectExpression([
            b.objectProperty(b.identifier('foo'), b.stringLiteral('bar')),
        ]);
        (0, ast_utils_1.setOrUpdateObjectProperty)(object, 'needle', b.stringLiteral('haystack'), 'This is a comment');
        const property = (0, ast_utils_1.getObjectProperty)(object, 'needle');
        (0, vitest_1.expect)(property?.comments).toHaveLength(1);
        // @ts-expect-error it must be defiend, otherwise we fail anyway
        (0, vitest_1.expect)(property?.comments[0].value).toBe(' This is a comment');
    });
});
(0, vitest_1.describe)('parse and print JSON-C', () => {
    vitest_1.it.each([
        ['simple JSON', "{'foo': 'bar'}"],
        [
            'JSON-C with inline comment',
            `
    {
      "foo": "bar" // with an inline comment
    }
    `,
        ],
        [
            'JSON-C with multiple comments',
            `
    /*
     * let's throw in a block comment for good measure
     */  
    {
      // one line comment
      "foo": "bar", // another inline comment
      /* one more here */
      "dogs": /* and here */ "awesome",
    }
    /* and here */
    `,
        ],
    ])(`parses and prints JSON-C (%s)`, (_, json) => {
        const { ast, jsonObject } = (0, ast_utils_1.parseJsonC)(json);
        (0, vitest_1.expect)(ast?.type).toBe('Program');
        (0, vitest_1.expect)(jsonObject).toBeDefined();
        (0, vitest_1.expect)(jsonObject?.type).toBe('ObjectExpression');
        // @ts-expect-error we know it's defined due to the expect above
        (0, vitest_1.expect)((0, ast_utils_1.printJsonC)(ast)).toEqual(json);
    });
    (0, vitest_1.it)('returns undefined if the input is not valid JSON-C', () => {
        const { ast, jsonObject } = (0, ast_utils_1.parseJsonC)(`{
      "invalid": // "json"
    }`);
        (0, vitest_1.expect)(ast).toBeUndefined();
        (0, vitest_1.expect)(jsonObject).toBeUndefined();
    });
});
//# sourceMappingURL=ast-utils.test.js.map