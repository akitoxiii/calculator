"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLastImportLineLocation = exports.patchMainActivity = exports.findActivitySourceFile = void 0;
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const Sentry = __importStar(require("@sentry/node"));
// @ts-expect-error - clack is ESM and TS complains about that. It works though
const clack = __importStar(require("@clack/prompts"));
const chalk_1 = __importDefault(require("chalk"));
const templates_1 = require("./templates");
const ast_utils_1 = require("../utils/ast-utils");
/**
 * Looks in src/main/java or src/main/kotlin for the specified {@link packageName} and
 * {@link activityName} by concatenating them. For example:
 *
 * src/
 *   main/
 *     java/ or kotlin/
 *       my.package.name/
 *         ui/
 *           MainActivity.kt
 *
 * src/main/java can contain both .java and .kt sources, whilst src/main/kotlin only .kt
 *
 * @param appDir
 * @param packageName
 * @param activityName
 * @returns path to the Main Activity
 */
function findActivitySourceFile(appDir, packageName, activityName) {
    const javaSrcDir = path.join(appDir, 'src', 'main', 'java');
    let possibleActivityPath;
    // if activity name starts with a dot, this means we need to concat packagename with it, otherwise
    // the package name is already specified in the activity name itself
    const packageNameParts = activityName.startsWith('.')
        ? packageName.split('.')
        : [];
    const activityNameParts = activityName.split('.');
    if (fs.existsSync(javaSrcDir)) {
        possibleActivityPath = (0, ast_utils_1.findFile)(path.join(javaSrcDir, ...packageNameParts, ...activityNameParts), ['.kt', '.java']);
    }
    if (!possibleActivityPath || !fs.existsSync(possibleActivityPath)) {
        const kotlinSrcDir = path.join(appDir, 'src', 'main', 'kotlin');
        if (fs.existsSync(kotlinSrcDir)) {
            possibleActivityPath = (0, ast_utils_1.findFile)(path.join(kotlinSrcDir, ...packageNameParts, ...activityNameParts), ['.kt']);
        }
    }
    return possibleActivityPath;
}
exports.findActivitySourceFile = findActivitySourceFile;
/**
 * Patches Main Activity with the test error code snippet by the specified path {@link activityFile}.
 * Finds activity's `onCreate` method, adds the snippet and necessary imports.
 *
 * ```kotlin
 * import something
 * import something.something
 * import io.sentry.Sentry <-- this is added by us
 *
 * override fun onCreate(savedInstanceState: Bundle?) {
 *   super.onCreate(savedInstanceState)
 *   // the snippet goes here <--
 *   doSomething()
 * }
 * ```
 *
 * @param activityFile
 * @returns true if successfully patched, false otherwise
 */
function patchMainActivity(activityFile) {
    if (!activityFile || !fs.existsSync(activityFile)) {
        clack.log.warn('No main activity source file found in filesystem.');
        Sentry.captureException('No main activity source file');
        return false;
    }
    const activityContent = fs.readFileSync(activityFile, 'utf8');
    if (/import\s+io\.sentry\.Sentry;?/i.test(activityContent)) {
        // sentry is already configured
        clack.log.success(chalk_1.default.greenBright(`${chalk_1.default.bold('Main Activity')} is already patched with test error snippet.`));
        return true;
    }
    const importIndex = getLastImportLineLocation(activityContent);
    let newActivityContent;
    if (activityFile.endsWith('.kt')) {
        newActivityContent =
            activityContent.slice(0, importIndex) +
                templates_1.sentryImportKt +
                activityContent.slice(importIndex);
    }
    else {
        newActivityContent =
            activityContent.slice(0, importIndex) +
                templates_1.sentryImport +
                activityContent.slice(importIndex);
    }
    const onCreateMatch = /super\.onCreate\(.*?\);?/i.exec(newActivityContent);
    if (!onCreateMatch) {
        clack.log.warn('No onCreate method found in main activity.');
        Sentry.captureException('No onCreate method');
        return false;
    }
    const onCreateIndex = onCreateMatch.index + onCreateMatch[0].length;
    if (activityFile.endsWith('.kt')) {
        newActivityContent =
            newActivityContent.slice(0, onCreateIndex) +
                templates_1.testErrorSnippetKt +
                newActivityContent.slice(onCreateIndex);
    }
    else {
        newActivityContent =
            newActivityContent.slice(0, onCreateIndex) +
                templates_1.testErrorSnippet +
                newActivityContent.slice(onCreateIndex);
    }
    fs.writeFileSync(activityFile, newActivityContent, 'utf8');
    clack.log.success(chalk_1.default.greenBright(`Patched ${chalk_1.default.bold('Main Activity')} with the Sentry test error snippet.`));
    return true;
}
exports.patchMainActivity = patchMainActivity;
/**
 * Returns the string index of the last import statement in the given code file.
 * Works for both Java and Kotlin import statements.
 *
 * @param sourceCode
 * @returns the insert index, or 0 if none found.
 */
function getLastImportLineLocation(sourceCode) {
    const importRegex = /import(?:\sstatic)?\s+[\w.*]+(?: as [\w.]+)?;?/gim;
    let importsMatch = importRegex.exec(sourceCode);
    let importIndex = 0;
    while (importsMatch) {
        importIndex = importsMatch.index + importsMatch[0].length + 1;
        importsMatch = importRegex.exec(sourceCode);
    }
    return importIndex;
}
exports.getLastImportLineLocation = getLastImportLineLocation;
//# sourceMappingURL=code-tools.js.map