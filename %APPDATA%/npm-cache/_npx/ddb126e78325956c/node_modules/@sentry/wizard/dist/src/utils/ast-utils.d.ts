import * as recast from 'recast';
import x = recast.types;
import t = x.namedTypes;
/**
 * Checks if a file where we don't know its concrete file type yet exists
 * and returns the full path to the file with the correct file type.
 */
export declare function findFile(filePath: string, fileTypes?: string[]): string | undefined;
/**
 * checks for require('@sentry/*') syntax
 */
export declare function hasSentryContent(program: t.Program): boolean;
/**
 * Searches for a property of an ObjectExpression by name
 *
 * @param object the ObjectExpression to search in
 * @param name the name of the property to search for
 *
 * @returns the property if it exists
 */
export declare function getObjectProperty(object: t.ObjectExpression, name: string): t.Property | undefined;
/**
 * Attempts to find a property of an ObjectExpression by name. If it doesn't exist,
 * the property will be added to the ObjectExpression with the provided default value.
 *
 * @param object the parent object expression to search in
 * @param name the name of the property to search for
 * @param defaultValue the default value to set if the property doesn't exist
 *
 * @returns the
 */
export declare function getOrSetObjectProperty(object: t.ObjectExpression, name: string, defaultValue: t.Literal | t.BooleanLiteral | t.StringLiteral | t.ObjectExpression): t.Property;
/**
 * Sets a property of an ObjectExpression if it exists, otherwise adds it
 * to the ObjectExpression. Optionally, a comment can be added to the
 * property.
 *
 * @param object the ObjectExpression to set the property on
 * @param name the name of the property to set
 * @param value  the value of the property to set
 * @param comment (optional) a comment to add to the property
 */
export declare function setOrUpdateObjectProperty(object: t.ObjectExpression, name: string, value: t.Literal | t.BooleanLiteral | t.StringLiteral | t.ObjectExpression, comment?: string): void;
type JsonCParseResult = {
    jsonObject: t.ObjectExpression;
    ast: t.Program;
} | {
    jsonObject: undefined;
    ast: undefined;
};
/**
 * Parses a JSON string with (potential) comments (JSON-C) and returns the JS AST
 * that can be walked and modified with recast like a normal JS AST.
 *
 * This is done by wrapping the JSON-C string in parentheses, thereby making it
 * a JS `Program` with an `ExpressionStatement` as its body. The expression is then
 * extracted from the AST and returned alongside the AST.
 *
 * To preserve as much original formatting as possible, the returned `ast`
 * property should be passed to {@link `printJsonC`} to get the JSON-C string back.
 *
 * If the input is not valid JSON-C, the result will be undefined.
 *
 * @see {@link JsonCParseResult}
 *
 * @param jsonString a JSON-C string
 *
 * @returns a {@link JsonCParseResult}, containing either the JSON-C object and the AST or undefined in both cases
 */
export declare function parseJsonC(jsonString: string): JsonCParseResult;
/**
 * Takes the AST of a parsed JSON-C "program" and returns the JSON-C string without
 * any of the temporary JS wrapper code that was previously applied.
 *
 * Only use this in conjunction with {@link `parseJsonC`}
 *
 * @param ast the `ast` returned from {@link `parseJsonC`}
 *
 * @returns the JSON-C string
 */
export declare function printJsonC(ast: t.Program): string;
/**
 * Walks the program body and returns index of the last variable assignment initialized by require statement.
 * Only counts top level require statements.
 *
 * @returns index of the last `const foo = require('bar');` statement or -1 if none was found.
 */
export declare function getLastRequireIndex(program: t.Program): number;
/**
 * Walks the statements and removes require statements which first argument includes the predicate.
 * Only removes top level require statements like `const foo = require('bar');`
 *
 * @returns True if any require statement was removed.
 */
export declare function removeRequire(program: t.Program, predicate: string): boolean;
export {};
