"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNamespace = exports.addGradlePlugin = exports.selectAppFile = void 0;
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
const fs = __importStar(require("fs"));
const clack_1 = require("../utils/clack");
const templates_1 = require("./templates");
const bash = __importStar(require("../utils/bash"));
const Sentry = __importStar(require("@sentry/node"));
// @ts-expect-error - clack is ESM and TS complains about that. It works though
const clack = __importStar(require("@clack/prompts"));
const chalk_1 = __importDefault(require("chalk"));
const release_registry_1 = require("../utils/release-registry");
/**
 * A Gradle project may contain multiple modules, some of them may be applications, some of them may be libraries.
 * We are only interested in applications. For example:
 *
 * myproject/
 *   app/
 *   lib1/
 *   lib2/
 *   wearApp/
 *
 * In this case^ we are interested in app/ and wearApp/
 *
 * @param buildGradleFiles a list of build.gradle(.kts) paths that contain the com.android.application plugin
 * @returns the selected project for setting up
 */
async function selectAppFile(buildGradleFiles) {
    const appFiles = [];
    for (let index = 0; index < buildGradleFiles.length; index++) {
        const file = buildGradleFiles[index];
        const text = fs.readFileSync(file, 'utf8');
        if (/\(?["']com\.android\.application["']\)?(?!.*\S)/.test(text)) {
            appFiles.push(file);
        }
    }
    if (appFiles.length === 0) {
        Sentry.setTag('custom-build-logic', true);
        const appFile = await (0, clack_1.abortIfCancelled)(clack.text({
            message: `Unable to find your app's directory. 
        Please enter the relative path to your app's build.gradle file from the root project`,
            placeholder: 'app/build.gradle.kts',
            validate(value) {
                if (!value.includes('.gradle') || !fs.existsSync(value))
                    return `Not a valid gradle file.`;
            },
        }));
        return appFile;
    }
    let appFile;
    if (appFiles.length === 1) {
        Sentry.setTag('multiple-projects', false);
        appFile = appFiles[0];
    }
    else {
        Sentry.setTag('multiple-projects', true);
        appFile = (await (0, clack_1.askForItemSelection)(appFiles, 'Which project do you want to add Sentry to?')).value;
    }
    Sentry.setTag('custom-build-logic', false);
    return appFile;
}
exports.selectAppFile = selectAppFile;
/**
 * Patches a build.gradle(.kts) file that contains `com.android.application` plugin.
 * There are multiple cases we have to handle here:
 *   - An existing `plugins {}` block:
 *     - We just have to add our plugin inside the block
 *   - No existing `plugins {}` block
 *     - We have to add the entire block in the beginning of the file, BUT *after imports*
 *
 * For example (2nd case):
 *
 * ```
 * import net.ltgt.gradle.errorprone.errorprone
 *
 * // our plugins block goes here <--
 * plugins {
 *   id("io.sentry.android.gradle") version "3.12.0"
 * }
 *
 * apply(plugin = "com.android.application")
 *
 * android {
 *   ...
 * }
 * ```
 *
 * In the end we run `./gradlew` to verify the config is build-able and not broken.
 *
 * @param appFile the selected Gradle application project
 * @returns true if successfully added Sentry Gradle config, false otherwise
 */
async function addGradlePlugin(appFile, orgSlug, projectSlug) {
    const gradleScript = fs.readFileSync(appFile, 'utf8');
    if (/\(?["']io\.sentry\.android\.gradle["']\)?/.test(gradleScript)) {
        // sentry gradle plugin is already installed
        clack.log.success(chalk_1.default.greenBright(`${chalk_1.default.bold('Sentry Gradle plugin')} is already added to the project.`));
        maybeAddSourceContextConfig(appFile, gradleScript, orgSlug, projectSlug);
        return true;
    }
    const pluginVersion = await (0, release_registry_1.fetchSdkVersion)('sentry.java.android.gradle-plugin');
    const pluginsBlockMatch = /plugins\s*{[^{}]*}/.exec(gradleScript);
    let newGradleScript;
    if (!pluginsBlockMatch) {
        // no "plugins {}" block, we can just add our own after imports
        const regex = /import\s+[\w.]+/gm;
        let importsMatch = regex.exec(gradleScript);
        let insertIndex = 0;
        while (importsMatch) {
            insertIndex = importsMatch.index + importsMatch[0].length + 1;
            importsMatch = regex.exec(gradleScript);
        }
        if (appFile.endsWith('.kts')) {
            newGradleScript =
                gradleScript.slice(0, insertIndex) +
                    (0, templates_1.pluginsBlockKts)(pluginVersion) +
                    gradleScript.slice(insertIndex);
        }
        else {
            newGradleScript =
                gradleScript.slice(0, insertIndex) +
                    (0, templates_1.pluginsBlock)(pluginVersion) +
                    gradleScript.slice(insertIndex);
        }
    }
    else {
        const insertIndex = pluginsBlockMatch.index + pluginsBlockMatch[0].length - 1;
        if (appFile.endsWith('.kts')) {
            newGradleScript =
                gradleScript.slice(0, insertIndex) +
                    (0, templates_1.pluginKts)(pluginVersion) +
                    gradleScript.slice(insertIndex);
        }
        else {
            newGradleScript =
                gradleScript.slice(0, insertIndex) +
                    (0, templates_1.plugin)(pluginVersion) +
                    gradleScript.slice(insertIndex);
        }
    }
    fs.writeFileSync(appFile, newGradleScript, 'utf8');
    maybeAddSourceContextConfig(appFile, newGradleScript, orgSlug, projectSlug);
    const buildSpinner = clack.spinner();
    buildSpinner.start('Running ./gradlew to verify changes (this may take a few minutes)...');
    try {
        await bash.execute('./gradlew');
        buildSpinner.stop(chalk_1.default.greenBright(`${chalk_1.default.bold('Sentry Gradle plugin')} added to the project.`));
    }
    catch (e) {
        buildSpinner.stop();
        Sentry.captureException('Gradle Sync failed');
        return false;
    }
    return true;
}
exports.addGradlePlugin = addGradlePlugin;
/**
 * Looks for the applications packageName (namespace) in the specified build.gradle(.kts) file.
 *
 * ```
 * android {
 *   namespace 'my.package.name' <-- this is what we extract
 *
 *   compileSdkVersion = 31
 *   ...
 * }
 * ```
 * @param appFile
 * @returns the packageName(namespace) of the app if available
 */
function getNamespace(appFile) {
    const gradleScript = fs.readFileSync(appFile, 'utf8');
    const namespaceMatch = /namespace\s*=?\s*['"]([^'"]+)['"]/i.exec(gradleScript);
    if (!namespaceMatch || namespaceMatch.length <= 1) {
        clack.log.warn('Unable to determine application package name.');
        Sentry.captureException('No package name');
        return undefined;
    }
    const namespace = namespaceMatch[1];
    return namespace;
}
exports.getNamespace = getNamespace;
/**
 * Adds source context configuration to the gradleScript if `sentry {}` block is not yet configured,
 *
 * @param appFile
 * @param gradleScript
 */
function maybeAddSourceContextConfig(appFile, gradleScript, orgSlug, projectSlug) {
    if (!/sentry\s*\{[^}]*\}/i.test(gradleScript)) {
        // if no sentry {} block is configured, we add our own with source context enabled
        if (appFile.endsWith('.kts')) {
            fs.appendFileSync(appFile, (0, templates_1.sourceContextKts)(orgSlug, projectSlug), 'utf8');
        }
        else {
            fs.appendFileSync(appFile, (0, templates_1.sourceContext)(orgSlug, projectSlug), 'utf8');
        }
    }
}
//# sourceMappingURL=gradle.js.map