{"version":3,"file":"File.js","sourceRoot":"","sources":["../../../lib/Helper/File.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,uCAAyB;AACzB,2CAA6B;AAE7B,MAAM,cAAc,GAAG,CAAC,iBAAiB,EAAE,aAAa,EAAE,YAAY,CAAC,CAAC;AAExE,SAAgB,iBAAiB,CAC/B,WAAmB,EACnB,IAI2B,EAC3B,GAAG,IAAe;IAElB,MAAM,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE;QACrC,MAAM,EAAE,cAAc;KACvB,CAAC,CAAC;IACH,IAAI,EAAE,GAAG,OAAO,CAAC,OAAO,EAAE,CAAC;IAC3B,OAAO,CAAC,OAAO,CAAC,CAAC,KAAa,EAAE,EAAE;QAChC,MAAM,QAAQ,GAAG,EAAE,CAAC,YAAY,CAAC,KAAK,EAAE;YACtC,QAAQ,EAAE,OAAO;SAClB,CAAC,CAAC;QACH,EAAE,GAAG,EAAE;aACJ,IAAI,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,QAAQ,EAAE,KAAK,EAAE,GAAG,IAAI,CAAC,CAAC;aAC1C,IAAI,CAAC,CAAC,WAAW,EAAE,EAAE;YACpB,IAAI,WAAW,IAAI,IAAI,IAAI,QAAQ,KAAK,WAAW,EAAE;gBACnD,EAAE,CAAC,aAAa,CAAC,KAAK,EAAE,WAAW,CAAC,CAAC;aACtC;QACH,CAAC,CAAC,CAAC;IACP,CAAC,CAAC,CAAC;IACH,OAAO,EAAE,CAAC;AACZ,CAAC;AA1BD,8CA0BC;AAED,SAAgB,UAAU,CAAC,WAAmB;IAC5C,OAAO,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE;QAC5B,MAAM,EAAE,cAAc;KACvB,CAAC,CAAC;AACL,CAAC;AAJD,gCAIC;AAED,SAAgB,MAAM,CAAC,WAAmB;IACxC,MAAM,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE;QACrC,MAAM,EAAE,cAAc;KACvB,CAAC,CAAC;IACH,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE;QACxB,OAAO,KAAK,CAAC;KACd;IACD,OAAO,OAAO,CAAC,MAAM,CAAC,CAAC,IAAa,EAAE,KAAa,EAAE,EAAE;QACrD,OAAO,IAAI,IAAI,EAAE,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;IACtC,CAAC,EAAE,IAAI,CAAC,CAAC;AACX,CAAC;AAVD,wBAUC;AAED,SAAgB,cAAc,CAC5B,WAAmB,EACnB,cAAsB;IAEtB,MAAM,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE;QACrC,MAAM,EAAE,cAAc;KACvB,CAAC,CAAC;IACH,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE;QACxB,OAAO,KAAK,CAAC;KACd;IACD,OAAO,OAAO,CAAC,MAAM,CAAC,CAAC,IAAa,EAAE,KAAa,EAAE,EAAE;QACrD,OAAO,CAAC,CAAC,CAAC,IAAI,IAAI,EAAE,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,QAAQ,EAAE,CAAC,KAAK,CAAC,cAAc,CAAC,CAAC,CAAC;IAC7E,CAAC,EAAE,IAAI,CAAC,CAAC;AACX,CAAC;AAbD,wCAaC","sourcesContent":["import * as fs from 'fs';\nimport * as glob from 'glob';\n\nconst IGNORE_PATTERN = ['node_modules/**', 'ios/Pods/**', '**/Pods/**'];\n\nexport function patchMatchingFile(\n  globPattern: string,\n  func: (\n    content: string,\n    match: string,\n    ...args: unknown[]\n  ) => Promise<string | void>,\n  ...args: unknown[]\n): Promise<void> {\n  const matches = glob.sync(globPattern, {\n    ignore: IGNORE_PATTERN,\n  });\n  let rv = Promise.resolve();\n  matches.forEach((match: string) => {\n    const contents = fs.readFileSync(match, {\n      encoding: 'utf-8',\n    });\n    rv = rv\n      .then(() => func(contents, match, ...args))\n      .then((newContents) => {\n        if (newContents != null && contents !== newContents) {\n          fs.writeFileSync(match, newContents);\n        }\n      });\n  });\n  return rv;\n}\n\nexport function matchFiles(globPattern: string): string[] {\n  return glob.sync(globPattern, {\n    ignore: IGNORE_PATTERN,\n  });\n}\n\nexport function exists(globPattern: string): boolean {\n  const matches = glob.sync(globPattern, {\n    ignore: IGNORE_PATTERN,\n  });\n  if (matches.length === 0) {\n    return false;\n  }\n  return matches.reduce((prev: boolean, match: string) => {\n    return prev && fs.existsSync(match);\n  }, true);\n}\n\nexport function matchesContent(\n  globPattern: string,\n  contentPattern: RegExp,\n): boolean {\n  const matches = glob.sync(globPattern, {\n    ignore: IGNORE_PATTERN,\n  });\n  if (matches.length === 0) {\n    return false;\n  }\n  return matches.reduce((prev: boolean, match: string) => {\n    return !!(prev && fs.readFileSync(match).toString().match(contentPattern));\n  }, true);\n}\n"]}