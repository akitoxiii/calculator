"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeXcodeProject = exports.findDebugFilesUploadPhase = exports.unPatchDebugFilesUploadPhase = exports.addDebugFilesUploadPhaseWithCli = exports.addDebugFilesUploadPhaseWithBundledScripts = exports.addSentryWithCliToBundleShellScript = exports.addSentryWithBundledScriptsToBundleShellScript = exports.doesBundlePhaseIncludeSentry = exports.findBundlePhase = exports.removeSentryFromBundleShellScript = exports.unPatchBundlePhase = exports.patchBundlePhase = exports.ErrorPatchSnippet = exports.getValidExistingBuildPhases = void 0;
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
/* eslint-disable @typescript-eslint/no-unsafe-call */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
const fs = __importStar(require("node:fs"));
// @ts-expect-error - clack is ESM and TS complains about that. It works though
const clack = __importStar(require("@clack/prompts"));
const chalk_1 = __importDefault(require("chalk"));
const clack_1 = require("../utils/clack");
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function getValidExistingBuildPhases(xcodeProject) {
    const map = {};
    const raw = xcodeProject.hash.project.objects.PBXShellScriptBuildPhase || {};
    for (const key in raw) {
        const val = raw[key];
        val.isa && (map[key] = val);
    }
    return map;
}
exports.getValidExistingBuildPhases = getValidExistingBuildPhases;
class ErrorPatchSnippet {
    snippet;
    constructor(snippet) {
        this.snippet = snippet;
    }
}
exports.ErrorPatchSnippet = ErrorPatchSnippet;
async function patchBundlePhase(bundlePhase, patch) {
    if (!bundlePhase) {
        clack.log.warn(`Could not find ${chalk_1.default.cyan('Bundle React Native code and images')} build phase.`);
        return;
    }
    const bundlePhaseIncludesSentry = doesBundlePhaseIncludeSentry(bundlePhase);
    if (bundlePhaseIncludesSentry) {
        clack.log.warn(`Build phase ${chalk_1.default.cyan('Bundle React Native code and images')} already includes Sentry.`);
        return;
    }
    const script = JSON.parse(bundlePhase.shellScript);
    const patchedScript = patch(script);
    if (patchedScript instanceof ErrorPatchSnippet) {
        await (0, clack_1.showCopyPasteInstructions)({
            filename: 'Xcode project',
            codeSnippet: patchedScript.snippet,
            hint: `Apply in the 'Bundle React Native code and images' build phase`,
        });
        return;
    }
    bundlePhase.shellScript = JSON.stringify(patchedScript);
    clack.log.success(`Patched Build phase ${chalk_1.default.cyan('Bundle React Native code and images')}.`);
}
exports.patchBundlePhase = patchBundlePhase;
function unPatchBundlePhase(bundlePhase) {
    if (!bundlePhase) {
        clack.log.warn(`Could not find ${chalk_1.default.cyan('Bundle React Native code and images')} build phase.`);
        return;
    }
    if (!bundlePhase.shellScript.match(/sentry-cli\s+react-native\s+xcode/i) &&
        !bundlePhase.shellScript.includes('sentry-xcode.sh')) {
        clack.log.success(`Build phase ${chalk_1.default.cyan('Bundle React Native code and images')} does not include Sentry.`);
        return;
    }
    bundlePhase.shellScript = JSON.stringify(removeSentryFromBundleShellScript(JSON.parse(bundlePhase.shellScript)));
    clack.log.success(`Build phase ${chalk_1.default.cyan('Bundle React Native code and images')} unpatched successfully.`);
}
exports.unPatchBundlePhase = unPatchBundlePhase;
function removeSentryFromBundleShellScript(script) {
    return (script
        // remove sentry properties export
        .replace(/^export SENTRY_PROPERTIES=sentry.properties\r?\n/m, '')
        .replace(/^\/bin\/sh .*?..\/node_modules\/@sentry\/react-native\/scripts\/collect-modules.sh"?\r?\n/m, '')
        // unwrap react-native-xcode.sh command.  In case someone replaced it
        // entirely with the sentry-cli command we need to put the original
        // version back in.
        .replace(/\.\.\/node_modules\/@sentry\/cli\/bin\/sentry-cli\s+react-native\s+xcode\s+\$REACT_NATIVE_XCODE/i, '$REACT_NATIVE_XCODE')
        .replace(
    //  eslint-disable-next-line no-useless-escape
    /\"\/bin\/sh.*?sentry-xcode.sh\s+\$REACT_NATIVE_XCODE/i, 
    // eslint-disable-next-line no-useless-escape
    '"$REACT_NATIVE_XCODE'));
}
exports.removeSentryFromBundleShellScript = removeSentryFromBundleShellScript;
function findBundlePhase(buildPhases) {
    return Object.values(buildPhases).find((buildPhase) => buildPhase.shellScript.match(/\/scripts\/react-native-xcode\.sh/i));
}
exports.findBundlePhase = findBundlePhase;
function doesBundlePhaseIncludeSentry(buildPhase) {
    const containsSentryCliRNCommand = !!buildPhase.shellScript.match(/sentry-cli\s+react-native\s+xcode/i);
    const containsBundledScript = buildPhase.shellScript.includes('sentry-xcode.sh');
    return containsSentryCliRNCommand || containsBundledScript;
}
exports.doesBundlePhaseIncludeSentry = doesBundlePhaseIncludeSentry;
function addSentryWithBundledScriptsToBundleShellScript(script) {
    let patchedScript = script;
    const isLikelyPlainReactNativeScript = script.includes('$REACT_NATIVE_XCODE');
    if (isLikelyPlainReactNativeScript) {
        patchedScript = script.replace('$REACT_NATIVE_XCODE', 
        // eslint-disable-next-line no-useless-escape
        '\\"/bin/sh ../node_modules/@sentry/react-native/scripts/sentry-xcode.sh $REACT_NATIVE_XCODE\\"');
    }
    const isLikelyExpoScript = script.includes('expo');
    if (isLikelyExpoScript) {
        const SENTRY_REACT_NATIVE_XCODE_PATH = "`\"$NODE_BINARY\" --print \"require('path').dirname(require.resolve('@sentry/react-native/package.json')) + '/scripts/sentry-xcode.sh'\"`";
        patchedScript = script.replace(/^.*?(packager|scripts)\/react-native-xcode\.sh\s*(\\'\\\\")?/m, 
        // eslint-disable-next-line no-useless-escape
        (match) => `/bin/sh ${SENTRY_REACT_NATIVE_XCODE_PATH} ${match}`);
    }
    if (patchedScript === script) {
        // No changes were made
        clack.log.error(`Failed to patch ${chalk_1.default.cyan('Bundle React Native code and images')} build phase.`);
        if (isLikelyExpoScript) {
            return new ErrorPatchSnippet((0, clack_1.makeCodeSnippet)(true, (unchanged, plus, _minus) => {
                return unchanged(`${plus(`/bin/sh \`"$NODE_BINARY" --print "require('path').dirname(require.resolve('@sentry/react-native/package.json')) + '/scripts/sentry-xcode.sh'"\``)} \`"$NODE_BINARY" --print "require('path').dirname(require.resolve('react-native/package.json')) + '/scripts/react-native-xcode.sh'"\``);
            }));
        }
        else {
            // plain react-native
            return new ErrorPatchSnippet((0, clack_1.makeCodeSnippet)(true, (unchanged, plus, _minus) => {
                return unchanged(`WITH_ENVIRONMENT="$REACT_NATIVE_PATH/scripts/xcode/with-environment.sh"
REACT_NATIVE_XCODE="$REACT_NATIVE_PATH/scripts/react-native-xcode.sh"

/bin/sh -c "$WITH_ENVIRONMENT ${plus(`\\"/bin/sh ../node_modules/@sentry/react-native/scripts/sentry-xcode.sh `)}$REACT_NATIVE_XCODE${plus(`\\"`)}"
`);
            }));
        }
    }
    return patchedScript;
}
exports.addSentryWithBundledScriptsToBundleShellScript = addSentryWithBundledScriptsToBundleShellScript;
function addSentryWithCliToBundleShellScript(script) {
    if (!script.includes('$REACT_NATIVE_XCODE')) {
        clack.log.error(`Could not find $REACT_NATIVE_XCODE in ${chalk_1.default.cyan('Bundle React Native code and images')} build phase. Skipping patching.`);
        return new ErrorPatchSnippet((0, clack_1.makeCodeSnippet)(true, (unchanged, plus, _minus) => {
            return unchanged(`${plus(`export SENTRY_PROPERTIES=sentry.properties
export EXTRA_PACKAGER_ARGS="--sourcemap-output $DERIVED_FILE_DIR/main.jsbundle.map"
`)}
/bin/sh -c "$WITH_ENVIRONMENT ${plus(`\\"../node_modules/@sentry/cli/bin/sentry-cli react-native xcode`)} $REACT_NATIVE_XCODE${plus(`\\"`)}"
${plus(`/bin/sh -c "$WITH_ENVIRONMENT ../node_modules/@sentry/react-native/scripts/collect-modules.sh"`)}
`);
        }));
    }
    return ('export SENTRY_PROPERTIES=sentry.properties\n' +
        'export EXTRA_PACKAGER_ARGS="--sourcemap-output $DERIVED_FILE_DIR/main.jsbundle.map"\n' +
        script.replace('$REACT_NATIVE_XCODE', () => 
        // eslint-disable-next-line no-useless-escape
        '\\"../node_modules/@sentry/cli/bin/sentry-cli react-native xcode $REACT_NATIVE_XCODE\\"') +
        '\n/bin/sh -c "$WITH_ENVIRONMENT ../node_modules/@sentry/react-native/scripts/collect-modules.sh"\n');
}
exports.addSentryWithCliToBundleShellScript = addSentryWithCliToBundleShellScript;
function addDebugFilesUploadPhaseWithBundledScripts(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
xcodeProject, { debugFilesUploadPhaseExists }) {
    if (debugFilesUploadPhaseExists) {
        clack.log.warn(`Build phase ${chalk_1.default.cyan('Upload Debug Symbols to Sentry')} already exists.`);
        return;
    }
    xcodeProject.addBuildPhase([], 'PBXShellScriptBuildPhase', 'Upload Debug Symbols to Sentry', null, {
        shellPath: '/bin/sh',
        shellScript: `/bin/sh ../node_modules/@sentry/react-native/scripts/sentry-xcode-debug-files.sh`,
    });
    clack.log.success(`Added Build phase ${chalk_1.default.cyan('Upload Debug Symbols to Sentry')}.`);
}
exports.addDebugFilesUploadPhaseWithBundledScripts = addDebugFilesUploadPhaseWithBundledScripts;
function addDebugFilesUploadPhaseWithCli(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
xcodeProject, { debugFilesUploadPhaseExists }) {
    if (debugFilesUploadPhaseExists) {
        clack.log.warn(`Build phase ${chalk_1.default.cyan('Upload Debug Symbols to Sentry')} already exists.`);
        return;
    }
    xcodeProject.addBuildPhase([], 'PBXShellScriptBuildPhase', 'Upload Debug Symbols to Sentry', null, {
        shellPath: '/bin/sh',
        shellScript: `
WITH_ENVIRONMENT="../node_modules/react-native/scripts/xcode/with-environment.sh"
if [ -f "$WITH_ENVIRONMENT" ]; then
  . "$WITH_ENVIRONMENT"
fi
export SENTRY_PROPERTIES=sentry.properties
[ "$SENTRY_INCLUDE_NATIVE_SOURCES" = "true" ] && INCLUDE_SOURCES_FLAG="--include-sources" || INCLUDE_SOURCES_FLAG=""
../node_modules/@sentry/cli/bin/sentry-cli debug-files upload "$INCLUDE_SOURCES_FLAG" "$DWARF_DSYM_FOLDER_PATH"
`,
    });
    clack.log.success(`Added Build phase ${chalk_1.default.cyan('Upload Debug Symbols to Sentry')}.`);
}
exports.addDebugFilesUploadPhaseWithCli = addDebugFilesUploadPhaseWithCli;
function unPatchDebugFilesUploadPhase(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
xcodeProject) {
    const buildPhasesMap = xcodeProject.hash.project.objects.PBXShellScriptBuildPhase || {};
    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
    const debugFilesUploadPhaseResult = findDebugFilesUploadPhase(buildPhasesMap);
    if (!debugFilesUploadPhaseResult) {
        clack.log.success(`Build phase ${chalk_1.default.cyan('Upload Debug Symbols to Sentry')} not found.`);
        return;
    }
    const [debugFilesUploadPhaseKey] = debugFilesUploadPhaseResult;
    const firstTarget = xcodeProject.getFirstTarget().uuid;
    const nativeTargets = xcodeProject.hash.project.objects.PBXNativeTarget;
    // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
    delete buildPhasesMap[debugFilesUploadPhaseKey];
    // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
    delete buildPhasesMap[`${debugFilesUploadPhaseKey}_comment`];
    const phases = nativeTargets[firstTarget].buildPhases;
    if (phases) {
        for (let i = 0; i < phases.length; i++) {
            if (phases[i].value === debugFilesUploadPhaseKey) {
                phases.splice(i, 1);
                break;
            }
        }
    }
    clack.log.success(`Build phase ${chalk_1.default.cyan('Upload Debug Symbols to Sentry')} removed successfully.`);
}
exports.unPatchDebugFilesUploadPhase = unPatchDebugFilesUploadPhase;
function findDebugFilesUploadPhase(buildPhasesMap) {
    return Object.entries(buildPhasesMap).find(([_, buildPhase]) => {
        const containsCliDebugUpload = typeof buildPhase !== 'string' &&
            !!buildPhase.shellScript.match(/sentry-cli\s+(upload-dsym|debug-files upload)\b/);
        const containsBundledDebugUpload = typeof buildPhase !== 'string' &&
            buildPhase.shellScript.includes('sentry-xcode-debug-files.sh');
        return containsCliDebugUpload || containsBundledDebugUpload;
    });
}
exports.findDebugFilesUploadPhase = findDebugFilesUploadPhase;
function writeXcodeProject(xcodeProjectPath, xcodeProject) {
    const newContent = xcodeProject.writeSync();
    const currentContent = fs.readFileSync(xcodeProjectPath, 'utf-8');
    if (newContent === currentContent) {
        return;
    }
    fs.writeFileSync(xcodeProjectPath, newContent, 'utf-8');
    clack.log.success(chalk_1.default.green(`Xcode project ${chalk_1.default.cyan(xcodeProjectPath)} changes saved.`));
}
exports.writeXcodeProject = writeXcodeProject;
//# sourceMappingURL=xcode.js.map